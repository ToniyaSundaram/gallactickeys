'use strict';

const constant = require('../constant/global'),
  util = require('./common'),
  bs58 = require('bs58'),
  crypto = require('crypto'),
  keccak = require('js-sha3').keccak256,
  nacl = require('tweetnacl'),
  Rmd160 = require('ripemd160'),
  scrypt = require('scryptsy');

const _SEED_ENCODING = constant.crypto.seedHashEnco,
  _SEED_ALGORITHM = constant.crypto.seedHashAlgo,
  _SALT_SIZE = constant.crypto.saltSize,
  _IV_SIZE = constant.crypto.ivSize,
  _AC_ADDR_ID = constant.id.acId, // 1
  _VA_ADDR_ID = constant.id.vaId, // 2
  _PRV_KEY_ID = constant.id.privKeyId, // 3
  _PUB_KEY_ID = constant.id.pubKeyId, // 4
  _AC_ADDR_PREF = constant.address.acPrefix, // ac
  _VA_ADDR_PREF = constant.address.vaPrefix, // va
  _TM_ADDR_LENGTH = constant.address.tmLength,
  _AC_ADDR_LENGTH = constant.address.acLength,
  _VA_ADDR_LENGTH = constant.address.vaLength,
  _PUBKEY_LENGTH = constant.keyPair.publicKeyLength, // 32 bytes
  _PRIVKEY_LENGTH = constant.keyPair.privateKeyLength, // 64 bytes
  _AC_ADDR_PREFIX = constant.crypto.acAddrPrefix, // 12EC
  _VA_ADDR_PREFIX = constant.crypto.vaAddrPrefix, // 1E2A
  _PRV_KEY_PREFIX = constant.crypto.privKeyPrefix, // E913
  _PUB_KEY_PREFIX = constant.crypto.pubKeyPrefix, // 9005
  cxo = {};

/**
 * Creates keccak SHA-3 hash of the input
 * @param {Buffer|Array|String|Number} input the input data
 * @param {Number} [bytes=256] the SHA width
 * @return {Buffer}
 */
cxo.sha3 = function (input) {
  return keccak(input);
};

/**
 * Create SHA256 hash string
 * @param {Buffer|Array|String|Number} input input for hashing
 * @returns {Buffer} buffer of the hash
 */
cxo.sha256 = function (input) {
  return crypto.createHash('sha256').update(input).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @method ripemd160
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
cxo.ripemd160 = function (a, padded) {
  a = util.toBuffer(a)
  var hash = new Rmd160().update(a).digest();
  if (padded === true) {
    return util.setLength(hash, 32);
  } else {
    return hash;
  }
}

/**
 * Generating a key pair
 * @param {String} seedHash a string which hash of seed content
 * @returns {Object} contains publicKey and privateKey
 */
cxo.makeKeyPair = (seedHash) => {
  if (!util.isSeedHash(seedHash)) {
    throw new Error('String is not a valid seed hash');
  }
  let buffer = new Buffer(seedHash, 'hex');
  let keyPair = cxo.makeKeyPairFromSeed(buffer);
  return {
    publicKey: keyPair.publicKey,
    privateKey: keyPair.privateKey || keyPair.secretKey
  }
};

/**
 * Generating a 32 bytes of hex string
 * @param {String} mnemonic a random string
 * @returns {String} a hash string of the
 */
cxo.hashSeed = (seed = '', option = {}) => {
  let hash = crypto
    .createHash(option.algorithm || _SEED_ALGORITHM)
    .update(seed)
    .digest(option.encoding || _SEED_ENCODING)
    .toUpperCase();
  return hash;
};

/**
 * To Hash the given address based on number of hashing round
 * @param {String} addr given address string
 * @param {Number} round hashing round
 * @returns {Buffer} buffer format of hashed input
 */
cxo.hashAddr = (addr, round = 1) => {
  if (round === 0) {
    return addr;
  }
  addr = crypto.createHash('sha256').update(addr).digest();
  return cxo.hashAddr(addr, --round);
};

/**
 * Derive secret key from password with key derivation function
 * @param {String} password [User supplied password]
 * @param {String} salt [Randomly generated bytes]
 * @param {Object} option [Key derivation parameters]
 * @returns {Buffer} [Secret key derived from password]
 */

cxo.deriveKey = (password, salt, option = {}) => {
  if (typeof password === 'undefined' || password === null || !salt) {
    throw new Error('Must provide password and salt to derive a key');
  }

  option.kdf = option.kdf || 'pbkdf2';
  option.kdfparams = option.kdfparams || {};

  password = util.strToBuffer(password, 'utf8');
  salt = util.strToBuffer(salt);

  switch (option.kdf) {
    case 'pbkdf2': return cxo.pbkdf2Dk(password, salt, option.kdfparams);
    case 'scrypt': return cxo.scryptDk(password, salt, option.kdfparams);
    default: throw new Error('KDF method is not available yet. Please use pbkdf2 or scrypt for now');
  }
};

/**
 * To derive key using pbkdf2 algorithm
 * @param {Buffer} password given password
 * @param {Buffer} salt given salt
 * @param {Object} option given option like hashing round, memory factor or parallelization factor
 * @returns {Buffer} secret key in buffer format
 */
cxo.pbkdf2Dk = (password, salt, option = {}) => {
  let prf, c, dklen;

  prf = option.prf || constant.crypto.kdf.pbkdf2.prf;
  if (prf === 'hmac-sha256') prf = constant.crypto.kdf.pbkdf2.hash;

  c = option.c || constant.crypto.kdf.pbkdf2.c;
  dklen = option.dklen || constant.crypto.kdf.pbkdf2.dklen;

  return crypto.pbkdf2Sync(password, salt, c, dklen, prf);
};

/**
 * To derive key using scrypt algorithm
 * @param {Buffer} password given password
 * @param {Buffer} salt given salt
 * @param {Object} option given option like hashing round, memory factor or parallelization factor
 * @returns {Buffer} secret key in buffer format
 */
cxo.scryptDk = (password, salt, option = {}) => {
  let n, r, p, dklen;

  n = option.n || constant.crypto.kdf.scrypt.n;
  r = option.r || constant.crypto.kdf.scrypt.r;
  p = option.p || constant.crypto.kdf.scrypt.p;
  dklen = option.dklen || constant.crypto.kdf.scrypt.dklen;

  if (typeof n !== 'number' || typeof r !== 'number' || typeof p !== 'number' || typeof dklen !== 'number') {
    throw new Error('Kdf params (n, r, p and dklen) must be a number type')
  }

  return scrypt(password, salt, n, r, p, dklen);
};

/**
 * Assemble key data object in secret-storage format.
 * @param {Buffer} derivedKey Password-derived secret key.
 * @param {String} privateKey Private key.
 * @param {Buffer} salt Randomly generated salt.
 * @param {Buffer} iv Initialization vector.
 * @param {Object} options Encryption parameters.
 * @param {String} options.kdf Key derivation function (default: pbkdf2).
 * @param {String} options.cipher Symmetric cipher (default: constants.cipher).
 * @param {Object} options.kdfparams KDF parameters (default: constants.<kdf>).
 * @return {Object}
 */
cxo.marshal = (derivedKey, privateKey, salt, iv, type, option = {}) => {
  var ciphertext, keyObject, algo;
  option.kdfparams = option.kdfparams || {};
  algo = option.cipher || constant.crypto.encryption.cipher;

  // encrypt using first 16 bytes of derived key
  ciphertext = cxo.encrypt(
    cxo.bs58Decode(privateKey), derivedKey.slice(0, 16),
    iv, algo
  ).toString('hex');

  keyObject = {
    address: cxo.getTmAddressByPrivKey(privateKey),
    crypto: {
      cipher: option.cipher || constant.crypto.encryption.cipher,
      ciphertext: ciphertext,
      cipherparams: { iv: iv.toString('hex') },
      mac: cxo.createMac(derivedKey, ciphertext)
    }
  };

  // encode address by given option
  keyObject.address = cxo.bs58Encode(keyObject.address, type);

  if (option.kdf === 'pbkdf2') {
    keyObject.crypto.kdf = 'pbkdf2';
    keyObject.crypto.kdfparams = {
      c: option.kdfparams.c || constant.crypto.kdf.pbkdf2.c,
      dklen: option.kdfparams.dklen || constant.crypto.kdf.pbkdf2.dklen,
      prf: option.kdfparams.prf || constant.crypto.kdf.pbkdf2.prf,
      salt: salt.toString('hex')
    };
  }
  else if (option.kdf === 'scrypt') {
    keyObject.crypto.kdf = 'scrypt';
    keyObject.crypto.kdfparams = {
      n: option.kdfparams.n || constant.crypto.kdf.scrypt.n,
      r: option.kdfparams.r || constant.crypto.kdf.scrypt.r,
      p: option.kdfparams.p || constant.crypto.kdf.scrypt.p,
      dklen: option.kdfparams.dklen || constant.crypto.kdf.scrypt.dklen,
      salt: salt.toString('hex')
    };
  }

  return keyObject;
};

/**
 * Symmetric private key encryption using secret (derived) key.
 * @param {String} text Data to be encrypted.
 * @param {Buffer} key Secret key.
 * @param {Buffer} iv Initialization vector.
 * @param {String} algo Encryption algorithm (default: constants.cipher).
 * @return {Buffer} Encrypted data.
 */
cxo.encrypt = (text, key, iv, algo) => {
  var cipher, ciphertext;
  algo = algo || constant.crypto.encryption.cipher;

  if (!cxo.isCipherAvailable(algo)) {
    throw new Error(algo + ' is not available')
  };

  cipher = crypto.createCipheriv(algo, key, iv);
  ciphertext = cipher.update(util.strToBuffer(text));

  return Buffer.concat([ciphertext, cipher.final()]);
};

/**
 * Symmetric private key decryption using secret (derived) key.
 * @param {Buffer} ciphertext Data to be decrypted.
 * @param {Buffer} key Secret key.
 * @param {Buffer} iv Initialization vector.
 * @param {String} algo Encryption algorithm (default: constants.cipher).
 * @return {Buffer} Decrypted data.
 */
cxo.decrypt = (ciphertext, key, iv, algo) => {
  var decipher, plaintext;
  algo = algo || constant.crypto.encryption.cipher;

  if (!cxo.isCipherAvailable(algo)) {
    throw new Error(algo + ' is not available');
  }

  decipher = crypto.createDecipheriv(algo, key, iv);
  plaintext = decipher.update(ciphertext);

  return Buffer.concat([plaintext, decipher.final()]);
};

/**
 * Get the Address based on public key
 * @param {String} publicKey 32bytes of Hex String
 */
cxo.getTmAddressByPubKey = (publicKey) => {
  try {
    let isTmPublicKey = false, isPublicKey = false;
    isTmPublicKey = util.isHexString(publicKey) ? cxo.isTmPublicKey(publicKey) : false;
    isPublicKey =isTmPublicKey ? false : cxo.isPublicKey(publicKey);

    if ((isTmPublicKey || isPublicKey) instanceof Error) {
      throw isTmPublicKey || isPublicKey;
    }
    if (isPublicKey) { publicKey = cxo.bs58Decode(publicKey); }
  }
  catch (e) {
    let err = new Error('given Public Key string is invalid! unable to proceed');
    err.rawErr = e;
    throw err;
  }

  return crypto
    .createHash('sha256')
    .update(util.strToBuffer(publicKey))
    .digest('hex')
    .toUpperCase()
    .slice(0, 40);
};

/**
 * Get the tm Address based on base 58 encoded or 64 bytes hex string
 * @param {String} privateKey base 58 encoded or 64 bytes hex string
 */
cxo.getTmAddressByPrivKey = (privateKey) => {
  let publicKey = cxo.getTmPubKeyByPrivKey(privateKey);
  return cxo.getTmAddressByPubKey(publicKey);
};

/**
 * Get Account Address based on given private key
 * @param {String} privateKey 64bytes of hex string
 */
cxo.getAcAddrByPrivKey = (privateKey) => {
  return cxo.bs58Encode(cxo.getTmAddressByPrivKey(privateKey), _AC_ADDR_ID);
};

/**
 * Get Validator Address based on given private key
 * @param {String} privateKey 64 bytes of hex string
 */
cxo.getVaAddrByPrivKey = (privateKey) => {
  return cxo.bs58Encode(cxo.getTmAddressByPrivKey(privateKey), _VA_ADDR_ID);
};

/**
 * Get a tm public key based on given private key
 * @param {String} privateKey a base 58 encoded string
 * @returns {String} a 32 bytes of hex string a.k.a tm public key
 */
cxo.getTmPubKeyByPrivKey = (privateKey) => {
  try {
    let isTmPrivateKey = false, isPrivateKey = false;
    isTmPrivateKey = util.isHexString(privateKey) ? cxo.isTmPrivateKey(privateKey) : false;
    isPrivateKey = isTmPrivateKey ? false : cxo.isPrivateKey(privateKey);

    if ((isTmPrivateKey || isPrivateKey) instanceof Error) {
      throw isTmPrivateKey || isPrivateKey
    }
    if (isPrivateKey) { privateKey = cxo.bs58Decode(privateKey); }
  }
  catch (e) {
    let err = new Error('given Private Key string is invalid! unable to proceed');
    err.rawErr = e;
    throw err;
  }

  return privateKey.substring(64, 128);
};

/**
 * Encode string using bs58 encoding
 * @param {String} s a hex string
 * @param {Number} type a number that decide to encode as a Validator or Account Address or private key, public key
 * @returns {String} An account/validator bs58 encoded address string
 */
cxo.bs58Encode = (s, type) => {
  let newAddr, suffix, checksum;
  if (type === _AC_ADDR_ID && !cxo.isAddress(s)) {
    throw new Error('Address is not a valid Address string');
  }
  else if (type === _PRV_KEY_ID && !cxo.isTmPrivateKey) {
    throw new Error('Private Key is not a Private Key string');
  }
  else if (type === _PUB_KEY_ID && !cxo.isTmPublicKey(s)) {
    throw new Error('Public Key is not a Public Key string');
  }

  switch (type) {
    case _AC_ADDR_ID: suffix = _AC_ADDR_PREFIX; break;
    case _VA_ADDR_ID: suffix = _VA_ADDR_PREFIX; break;
    case _PRV_KEY_ID: suffix = _PRV_KEY_PREFIX; break;
    case _PUB_KEY_ID: suffix = _PUB_KEY_PREFIX; break;
    default: throw new Error('This type is currently not supported yet!');
  }

  newAddr = Buffer.from(s, 'hex');
  suffix = Buffer.from(suffix, 'hex');

  newAddr = Buffer.concat([suffix, newAddr], suffix.length + newAddr.length);

  // get 4 bytes of hex sum
  checksum = cxo.createChecksum(newAddr);

  // concat new address with the checksum
  newAddr = Buffer.concat([newAddr, checksum], newAddr.length + checksum.length);
  newAddr = bs58.encode(newAddr);
  return newAddr;
};

/**
 * To decode the encoded string and return the original string
 * @param {String} s a validator or account encoded address
 * @returns {String} a string of TM address
 */
cxo.bs58Decode = (s) => {
  let oriStr, givenChecksum, foundChecksum;

  oriStr = bs58.decode(s);
  foundChecksum = oriStr.slice(-4).toString('hex'); // take last 4 bytes as checksum
  givenChecksum = cxo.createChecksum(oriStr.slice(0, -4)).toString('hex'); // generate checksum

  if (foundChecksum !== givenChecksum) {
    throw new Error('Invalid Checksum! Unable to decode.');
  }

  oriStr = oriStr.slice(0, -4).slice(2);
  oriStr = util.bytesToHexUpperString(oriStr)
  return oriStr;
};

/**
 * Check if the selected cipher is available.
 * @param {string} algo Encryption algorithm.
 * @return {boolean} If available true, otherwise false.
 */
cxo.isCipherAvailable = (cipher) => {
  return crypto.getCiphers().some(function (name) {
    return name === cipher;
  });
};

/**
 * Generate key pair using ed25519 curve as encryption algorithm
 * @param {Buffer} buffer [An array of bytes of seedHash hex string]
 * @returns {Object} [Contains public key and private key pair]
 */
cxo.makeKeyPairFromSeed = (buffer) => {
  return nacl.sign.keyPair.fromSeed(buffer);
};

/**
 * Sign message with the given private key
 * @param {Buffer} message [A 64bytes buffer of the stringify transaction json data]
 * @param {Buffer} pk [A 64 bytes buffer of the private key]
 * @returns {Buffer} [An encrypted message in Buffer format]
 */
cxo.sign = (message, pk) => {
  return nacl.sign.detached(message, pk);
}

/**
 * Calculate message authentication code from secret (derived) key and
 * encrypted text. The MAC is the sha256 hash of the byte array
 * formed by concatenating the second 16 bytes of the derived key with
 * the ciphertext key's contents.
 * @param {Buffer} derivedKey Secret key derived from password.
 * @param {Buffer} ciphertext Text encrypted with secret key.
 * @return {String} Hex-encoded MAC.
 */
cxo.createMac = (derivedKey, ciphertext) => {
  if (!derivedKey && !ciphertext) {
    throw new Error('Derived key and cipher text is required')
  }

  if (Buffer.isBuffer(derivedKey)) derivedKey = derivedKey.toString('hex');
  if (Buffer.isBuffer(ciphertext)) ciphertext = ciphertext.toString('hex');

  return crypto
    .createHash('sha256')
    .update(util.hexToUtf16le(derivedKey.slice(32, 64) + ciphertext))
    .digest()
    .toString('hex');
};

/**
 * A helper function to create checksum
 * @param {Buffer} addr a buffer of updated address with prefix
 * @returns {Buffer} 4 first bytes of hashed given addr
 */
cxo.createChecksum = (addr) => {
  return cxo.hashAddr(addr, 2).slice(0, 4);
}

/**
 * Validate string input whether it is a valid Address string
 * @param {String} s [address string]
 * @return {Boolean}
 */
cxo.isAddress = (s) => {
  const prefix = s.substring(0, 2);
  if (prefix === _AC_ADDR_PREF) return cxo.isAcAddress(s);
  else if (prefix === _VA_ADDR_PREF) return cxo.isVaAddress(s);
  else if (s.length === _TM_ADDR_LENGTH) return cxo.isTmAddress(s);
  else return false;
};

/**
 * Validate string if it is a valid tm address
 * @param {String} s address string
 * @returns {Boolean}
 */
cxo.isTmAddress = (s) => {
  if (!util.isHexString(s)) {
    return new Error('Address is not a valid Hex String')
  }
  return s.length === _TM_ADDR_LENGTH;
};

/**
 * Validate string if it is a valid ac address
 * @param {String} s address string
 * @returns {Boolean}
 */
cxo.isAcAddress = (s) => {
  if (s.length !== _AC_ADDR_LENGTH) {
    return false;
  }

  let tmAddress = cxo.bs58Decode(s);
  return cxo.isTmAddress(tmAddress);
};

/**
 * Validate string if it is a valid va address
 * @param {String} s address string
 * @returns {Boolean}
 */
cxo.isVaAddress = (s) => {
  if (s.length !== _VA_ADDR_LENGTH) {
    return false
  }

  let tmAddress = cxo.bs58Decode(s);
  return cxo.isTmAddress(tmAddress);
};

/**
 * Validate string input whether it is a valid tm public key string
 * @param {String} s [A string input]
 * @returns {Boolean}
 */
cxo.isTmPublicKey = (s) => {
  if (!util.isHexString(s)) {
    throw new Error('Public Key is not a valid Hex String')
  }

  return s.length === _PUBKEY_LENGTH;
};

/**
 * Validate string input whether it is a valid private key string
 * @param {String} s [A string input]
 * @returns {Boolean}
 */
cxo.isTmPrivateKey = (s) => {
  if (!util.isHexString(s)) {
    throw new Error('Private Key is not a valid Hex String')
  }

  return s.length === _PRIVKEY_LENGTH;
};

/**
 * Validate string input whether it is a valid public key string
 * @param {String} s [A string input]
 * @returns {Boolean}
 */
cxo.isPublicKey = (s) => {
  s = cxo.bs58Decode(s);
  return cxo.isTmPublicKey(s);
};

/**
 * Validate string input whether it is a valid private key string
 * @param {String} s [A string input]
 * @returns {Boolean}
 */
cxo.isPrivateKey = (s) => {
  s = cxo.bs58Decode(s);
  return cxo.isTmPrivateKey(s);
};

/**
 * generate salt
 * @param {Number} size the size of the random bytes
 * @returns {Buffer}
 */
cxo.generateSalt = (size = _SALT_SIZE) => {
  return crypto.randomBytes(size)
};

/**
 * generate Initialization vector
 * @param {Number} size the size of the random bytes
 * @returns {Buffer}
 */
cxo.generateIv = (size = _IV_SIZE) => {
  return crypto.randomBytes(size);
};

module.exports = cxo;